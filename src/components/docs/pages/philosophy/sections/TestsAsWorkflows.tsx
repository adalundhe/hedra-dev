import { Section } from "../../../sections"
import { CenterTextBlock, HighlightedText } from "../../../segments"
import { AiOutlineNodeExpand } from 'react-icons/ai'


const TestsAsWorkflows = ({
    subSectionName
}: {
    subSectionName: string
}) => <Section 
        subSectionName={subSectionName}
        >
            <div>
                <p>
                    When writing tests, we are most familiar with writing test code as a series of steps to be executed in sequential order. When
                    testing realistic usage of a system - while this representation might be suitable for simulating a user's surface level interactions - 
                    the underlying processes and events that triggered by those interactions are <HighlightedText>not</HighlightedText> sequential.
                </p>
                <br/>
                <p>
                    Consider a user submitting a form. The user enters some text into inputs, clicks some checkboxes, and then submits the form. On surface 
                    level this appears to be a perfectly sequential series of events, and thus can be simulated and tested as a sequential series of tasks 
                    in test code.
                </p>
                <br/>
                <p>
                    Behind the UI, modern applications and systems are executing a bevy of concurrent tasks for each sequential user "step" -
                    from API calls to validate critical fields, to submitting user input to machine learning pipelines for analysis and recommendations as the 
                    user types, to capturing page interaction events, to batching calls to third party providers to return relevant advertisements, etc. Accurate 
                    tests capture more than the surface level interaction, they test and validate the complex interconnected work each interaction triggers.
                </p>
                <br/>
                <p>
                    Given that the underlying pieces of work generated have clear and defined relationships with each other, it makes sense to both mentally
                    and computationally model this work as a graph. The ideal test representitave of a system under usage is then also a graph composed of 
                    discrete tasks simulating and validating the functionality of the underlying components responsible for the work generated by user
                    interaction events. 
                </p>
                <br/>
                <p>
                    Ideally, integration and end-to-end tests would accomplish this. However these tests lack the granularity to validate the 
                    underlying work triggered by user interaction. Indvidual step code in integration or end-to-end tests becomes entagled and intertwined 
                    with other test code when attempting to accomplish this, and it becomes a difficult to maintain the distinct task boundares required by graph 
                    structures. Eventually, most integration and end-to-end tests devolve into sequential workflows for the sake of speed, stability, 
                    and scalability.
                </p>
                <br/>
                <p>
                    By contrast, unit tests are written to be fast, efficient, and discrete. This is because unit tests focus on validating the 
                    functionality of the smallest testable components of a system. When we break down the complex work generated by user interaction into its 
                    smallest components, we find that the work generated corresponds directly to orchestrated execution of these discrete components.
                </p>
                <CenterTextBlock>
                    Instead of integration or end-to-end tests - to accurately test user impact on a system it makes more 
                    sense to compose unit tests into graph workflows.
                </CenterTextBlock>
                <div className="text-[2.5rem] text-center flex items-center justify-center pb-12">
                    <AiOutlineNodeExpand/>
                </div>
            </div>
        </Section>


export {
    TestsAsWorkflows
}