import { Section } from "../../../sections"
import { CenterTextBlock, HighlightedText } from "../../../segments"
import { AiOutlineNodeExpand } from 'react-icons/ai'


const TestsAsWorkflows = ({
    subSectionName
}: {
    subSectionName: string
}) => <Section 
        subSectionName={subSectionName}
        >
            <div>
                <p>
                    When writing tests, we are most familiar with writing test code as a series of steps to be executed in sequential order. However, when
                    simulating realistic usage of a system - while this representation might be suitable for simullating a user's surface level interaction, 
                    the underlying processes and events that user's interactions trigger are most certainly <HighlightedText>not</HighlightedText> sequential.
                </p>
                <br/>
                <p>
                    Consider a user submitting a form. The user enters some text into inputs, clicks some checkboxes, and then submits the form. On surface 
                    level this appears to be a perfectly sequential series of events, and thus can be simulated and tested as a sequential series of tasks 
                    in test code.
                </p>
                <br/>
                <p>
                    However, behind the UI, modern applications and systems are often executing a bevy of concurrent tasks for each sequential user "step",
                    from API calls to validate critical pieces of form data, to submitting user input to machine learning pipelines for analysis and 
                    recommendations as a user types, to capturing page interaction events, to batching calls to third party providers to return relevant 
                    advertisements, etc. Ideal and accurate tests capture not just the surface level interaction, but test and validate the plethora of
                    interconnected and interrelated work each interaction or step triggers.
                </p>
                <br/>
                <p>
                    Given that the underlying pieces of work generated have clear and defined relationships with each other, it makes sense to both mentally
                    and computationally model this work as a graph. As such, the ideal test that truly represents a system under user interaction is also a 
                    graph composed of discrete tasks simulating each piece of work. 
                </p>
                <br/>
                <p>
                    Ideally, integration and end-to-end tests would accomplish this, however these tests often lack the granularity to validate that the 
                    underlying work triggered by that interaction. Indvidual step code in integration and end-to-end tests often becomes so intwined with 
                    other steps that is becomes a difficult to maintain the clear boundares required for a graph structure to work. Inevitably, the result 
                    is that most integration and end-to-end tests devolve into sequential workflows for the sake of overall test speed, stability, and scalability.
                </p>
                <br/>
                <p>
                    By contrast, unit tests are commonly written to be fast, efficient, and contained. Individually unit tests focus on validating the 
                    functionality of discrete components of a system. When we break down the complex work generated by user interaction into its smallest
                    components, we find that the work a user generates corresponds to some orchestrated or organized execution of these discrete components.
                </p>
                <CenterTextBlock>
                    Instead of integration or end-to-end tests - to accurately test user impact on a system it makes more 
                    sense to compose unit tests into graph workflows.
                </CenterTextBlock>
                <div className="text-[2.5rem] text-center flex items-center justify-center pb-12">
                    <AiOutlineNodeExpand/>
                </div>
            </div>
        </Section>


export {
    TestsAsWorkflows
}